<?xml version="1.0" encoding="UTF-8"?>
<transformation>
  <info>
    <name>createFunctionProcedure</name>
    <description/>
    <extended_description/>
    <trans_version/>
    <trans_type>Normal</trans_type>
    <trans_status>0</trans_status>
    <directory>&#x2f;</directory>
    <parameters>
        <parameter>
            <name>OLAP</name>
            <default_value>olbiusdmsolap</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLAP_HOST</name>
            <default_value>127.0.0.1</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLAP_PORT</name>
            <default_value>3306</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLAP_PWD</name>
            <default_value>123456</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLAP_USER</name>
            <default_value>root</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLBIUS</name>
            <default_value>olbiusdms2</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLBIUS_HOST</name>
            <default_value>127.0.0.1</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLBIUS_PORT</name>
            <default_value>3306</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLBIUS_PWD</name>
            <default_value>123456</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>OLBIUS_USER</name>
            <default_value>root</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>commitSize</name>
            <default_value>1000</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>cur_date</name>
            <default_value>2016-04-01</default_value>
            <description/>
        </parameter>
        <parameter>
            <name>lastupdate</name>
            <default_value>1990-01-01</default_value>
            <description/>
        </parameter>
    </parameters>
    <log>
<trans-log-table><connection/>
<schema/>
<table/>
<size_limit_lines/>
<interval/>
<timeout_days/>
<field><id>ID_BATCH</id><enabled>Y</enabled><name>ID_BATCH</name></field><field><id>CHANNEL_ID</id><enabled>Y</enabled><name>CHANNEL_ID</name></field><field><id>TRANSNAME</id><enabled>Y</enabled><name>TRANSNAME</name></field><field><id>STATUS</id><enabled>Y</enabled><name>STATUS</name></field><field><id>LINES_READ</id><enabled>Y</enabled><name>LINES_READ</name><subject/></field><field><id>LINES_WRITTEN</id><enabled>Y</enabled><name>LINES_WRITTEN</name><subject/></field><field><id>LINES_UPDATED</id><enabled>Y</enabled><name>LINES_UPDATED</name><subject/></field><field><id>LINES_INPUT</id><enabled>Y</enabled><name>LINES_INPUT</name><subject/></field><field><id>LINES_OUTPUT</id><enabled>Y</enabled><name>LINES_OUTPUT</name><subject/></field><field><id>LINES_REJECTED</id><enabled>Y</enabled><name>LINES_REJECTED</name><subject/></field><field><id>ERRORS</id><enabled>Y</enabled><name>ERRORS</name></field><field><id>STARTDATE</id><enabled>Y</enabled><name>STARTDATE</name></field><field><id>ENDDATE</id><enabled>Y</enabled><name>ENDDATE</name></field><field><id>LOGDATE</id><enabled>Y</enabled><name>LOGDATE</name></field><field><id>DEPDATE</id><enabled>Y</enabled><name>DEPDATE</name></field><field><id>REPLAYDATE</id><enabled>Y</enabled><name>REPLAYDATE</name></field><field><id>LOG_FIELD</id><enabled>Y</enabled><name>LOG_FIELD</name></field><field><id>EXECUTING_SERVER</id><enabled>N</enabled><name>EXECUTING_SERVER</name></field><field><id>EXECUTING_USER</id><enabled>N</enabled><name>EXECUTING_USER</name></field><field><id>CLIENT</id><enabled>N</enabled><name>CLIENT</name></field></trans-log-table>
<perf-log-table><connection/>
<schema/>
<table/>
<interval/>
<timeout_days/>
<field><id>ID_BATCH</id><enabled>Y</enabled><name>ID_BATCH</name></field><field><id>SEQ_NR</id><enabled>Y</enabled><name>SEQ_NR</name></field><field><id>LOGDATE</id><enabled>Y</enabled><name>LOGDATE</name></field><field><id>TRANSNAME</id><enabled>Y</enabled><name>TRANSNAME</name></field><field><id>STEPNAME</id><enabled>Y</enabled><name>STEPNAME</name></field><field><id>STEP_COPY</id><enabled>Y</enabled><name>STEP_COPY</name></field><field><id>LINES_READ</id><enabled>Y</enabled><name>LINES_READ</name></field><field><id>LINES_WRITTEN</id><enabled>Y</enabled><name>LINES_WRITTEN</name></field><field><id>LINES_UPDATED</id><enabled>Y</enabled><name>LINES_UPDATED</name></field><field><id>LINES_INPUT</id><enabled>Y</enabled><name>LINES_INPUT</name></field><field><id>LINES_OUTPUT</id><enabled>Y</enabled><name>LINES_OUTPUT</name></field><field><id>LINES_REJECTED</id><enabled>Y</enabled><name>LINES_REJECTED</name></field><field><id>ERRORS</id><enabled>Y</enabled><name>ERRORS</name></field><field><id>INPUT_BUFFER_ROWS</id><enabled>Y</enabled><name>INPUT_BUFFER_ROWS</name></field><field><id>OUTPUT_BUFFER_ROWS</id><enabled>Y</enabled><name>OUTPUT_BUFFER_ROWS</name></field></perf-log-table>
<channel-log-table><connection/>
<schema/>
<table/>
<timeout_days/>
<field><id>ID_BATCH</id><enabled>Y</enabled><name>ID_BATCH</name></field><field><id>CHANNEL_ID</id><enabled>Y</enabled><name>CHANNEL_ID</name></field><field><id>LOG_DATE</id><enabled>Y</enabled><name>LOG_DATE</name></field><field><id>LOGGING_OBJECT_TYPE</id><enabled>Y</enabled><name>LOGGING_OBJECT_TYPE</name></field><field><id>OBJECT_NAME</id><enabled>Y</enabled><name>OBJECT_NAME</name></field><field><id>OBJECT_COPY</id><enabled>Y</enabled><name>OBJECT_COPY</name></field><field><id>REPOSITORY_DIRECTORY</id><enabled>Y</enabled><name>REPOSITORY_DIRECTORY</name></field><field><id>FILENAME</id><enabled>Y</enabled><name>FILENAME</name></field><field><id>OBJECT_ID</id><enabled>Y</enabled><name>OBJECT_ID</name></field><field><id>OBJECT_REVISION</id><enabled>Y</enabled><name>OBJECT_REVISION</name></field><field><id>PARENT_CHANNEL_ID</id><enabled>Y</enabled><name>PARENT_CHANNEL_ID</name></field><field><id>ROOT_CHANNEL_ID</id><enabled>Y</enabled><name>ROOT_CHANNEL_ID</name></field></channel-log-table>
<step-log-table><connection/>
<schema/>
<table/>
<timeout_days/>
<field><id>ID_BATCH</id><enabled>Y</enabled><name>ID_BATCH</name></field><field><id>CHANNEL_ID</id><enabled>Y</enabled><name>CHANNEL_ID</name></field><field><id>LOG_DATE</id><enabled>Y</enabled><name>LOG_DATE</name></field><field><id>TRANSNAME</id><enabled>Y</enabled><name>TRANSNAME</name></field><field><id>STEPNAME</id><enabled>Y</enabled><name>STEPNAME</name></field><field><id>STEP_COPY</id><enabled>Y</enabled><name>STEP_COPY</name></field><field><id>LINES_READ</id><enabled>Y</enabled><name>LINES_READ</name></field><field><id>LINES_WRITTEN</id><enabled>Y</enabled><name>LINES_WRITTEN</name></field><field><id>LINES_UPDATED</id><enabled>Y</enabled><name>LINES_UPDATED</name></field><field><id>LINES_INPUT</id><enabled>Y</enabled><name>LINES_INPUT</name></field><field><id>LINES_OUTPUT</id><enabled>Y</enabled><name>LINES_OUTPUT</name></field><field><id>LINES_REJECTED</id><enabled>Y</enabled><name>LINES_REJECTED</name></field><field><id>ERRORS</id><enabled>Y</enabled><name>ERRORS</name></field><field><id>LOG_FIELD</id><enabled>N</enabled><name>LOG_FIELD</name></field></step-log-table>
<metrics-log-table><connection/>
<schema/>
<table/>
<timeout_days/>
<field><id>ID_BATCH</id><enabled>Y</enabled><name>ID_BATCH</name></field><field><id>CHANNEL_ID</id><enabled>Y</enabled><name>CHANNEL_ID</name></field><field><id>LOG_DATE</id><enabled>Y</enabled><name>LOG_DATE</name></field><field><id>METRICS_DATE</id><enabled>Y</enabled><name>METRICS_DATE</name></field><field><id>METRICS_CODE</id><enabled>Y</enabled><name>METRICS_CODE</name></field><field><id>METRICS_DESCRIPTION</id><enabled>Y</enabled><name>METRICS_DESCRIPTION</name></field><field><id>METRICS_SUBJECT</id><enabled>Y</enabled><name>METRICS_SUBJECT</name></field><field><id>METRICS_TYPE</id><enabled>Y</enabled><name>METRICS_TYPE</name></field><field><id>METRICS_VALUE</id><enabled>Y</enabled><name>METRICS_VALUE</name></field></metrics-log-table>
    </log>
    <maxdate>
      <connection/>
      <table/>
      <field/>
      <offset>0.0</offset>
      <maxdiff>0.0</maxdiff>
    </maxdate>
    <size_rowset>10000</size_rowset>
    <sleep_time_empty>50</sleep_time_empty>
    <sleep_time_full>50</sleep_time_full>
    <unique_connections>N</unique_connections>
    <feedback_shown>Y</feedback_shown>
    <feedback_size>50000</feedback_size>
    <using_thread_priorities>Y</using_thread_priorities>
    <shared_objects_file/>
    <capture_step_performance>N</capture_step_performance>
    <step_performance_capturing_delay>1000</step_performance_capturing_delay>
    <step_performance_capturing_size_limit>100</step_performance_capturing_size_limit>
    <dependencies>
    </dependencies>
    <partitionschemas>
    </partitionschemas>
    <slaveservers>
    </slaveservers>
    <clusterschemas>
    </clusterschemas>
  <created_user>-</created_user>
  <created_date>2015&#x2f;09&#x2f;16 10&#x3a;12&#x3a;25.207</created_date>
  <modified_user>-</modified_user>
  <modified_date>2015&#x2f;09&#x2f;16 10&#x3a;12&#x3a;25.207</modified_date>
  </info>
  <notepads>
  </notepads>
  <connection>
    <name>olbius</name>
    <server>&#x24;&#x7b;OLBIUS_HOST&#x7d;</server>
    <type>MYSQL</type>
    <access>Native</access>
    <database>&#x24;&#x7b;OLBIUS&#x7d;</database>
    <port>&#x24;&#x7b;OLBIUS_PORT&#x7d;</port>
    <username>&#x24;&#x7b;OLBIUS_USER&#x7d;</username>
    <password>&#x24;&#x7b;OLBIUS_PWD&#x7d;</password>
    <servername/>
    <data_tablespace/>
    <index_tablespace/>
    <attributes>
      <attribute><code>FORCE_IDENTIFIERS_TO_LOWERCASE</code><attribute>N</attribute></attribute>
      <attribute><code>FORCE_IDENTIFIERS_TO_UPPERCASE</code><attribute>N</attribute></attribute>
      <attribute><code>IS_CLUSTERED</code><attribute>N</attribute></attribute>
      <attribute><code>PORT_NUMBER</code><attribute>&#x24;&#x7b;OLBIUS_PORT&#x7d;</attribute></attribute>
      <attribute><code>PRESERVE_RESERVED_WORD_CASE</code><attribute>N</attribute></attribute>
      <attribute><code>QUOTE_ALL_FIELDS</code><attribute>N</attribute></attribute>
      <attribute><code>STREAM_RESULTS</code><attribute>Y</attribute></attribute>
      <attribute><code>SUPPORTS_BOOLEAN_DATA_TYPE</code><attribute>Y</attribute></attribute>
      <attribute><code>SUPPORTS_TIMESTAMP_DATA_TYPE</code><attribute>Y</attribute></attribute>
      <attribute><code>USE_POOLING</code><attribute>N</attribute></attribute>
    </attributes>
  </connection>
  <connection>
    <name>olbiusolap</name>
    <server>&#x24;&#x7b;OLAP_HOST&#x7d;</server>
    <type>MYSQL</type>
    <access>Native</access>
    <database>&#x24;&#x7b;OLAP&#x7d;</database>
    <port>&#x24;&#x7b;OLAP_PORT&#x7d;</port>
    <username>&#x24;&#x7b;OLAP_USER&#x7d;</username>
    <password>&#x24;&#x7b;OLAP_PWD&#x7d;</password>
    <servername/>
    <data_tablespace/>
    <index_tablespace/>
    <attributes>
      <attribute><code>FORCE_IDENTIFIERS_TO_LOWERCASE</code><attribute>N</attribute></attribute>
      <attribute><code>FORCE_IDENTIFIERS_TO_UPPERCASE</code><attribute>N</attribute></attribute>
      <attribute><code>IS_CLUSTERED</code><attribute>N</attribute></attribute>
      <attribute><code>PORT_NUMBER</code><attribute>&#x24;&#x7b;OLAP_PORT&#x7d;</attribute></attribute>
      <attribute><code>PRESERVE_RESERVED_WORD_CASE</code><attribute>N</attribute></attribute>
      <attribute><code>QUOTE_ALL_FIELDS</code><attribute>N</attribute></attribute>
      <attribute><code>STREAM_RESULTS</code><attribute>Y</attribute></attribute>
      <attribute><code>SUPPORTS_BOOLEAN_DATA_TYPE</code><attribute>Y</attribute></attribute>
      <attribute><code>SUPPORTS_TIMESTAMP_DATA_TYPE</code><attribute>Y</attribute></attribute>
      <attribute><code>USE_POOLING</code><attribute>N</attribute></attribute>
    </attributes>
  </connection>
  <order>
  <hop> <from>create_func_getDateDim</from><to>check_exist_getDateDim_olap</to><enabled>Y</enabled> </hop>
  <hop> <from>create_func_getDateDim_olap</from><to>check_exist_generateSeriesBase</to><enabled>Y</enabled> </hop>
  <hop> <from>create_proc_generateSeriesBase</from><to>check_exist_generateSeries</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exist_getDateDim</from><to>is_exist_getDateDim</to><enabled>Y</enabled> </hop>
  <hop> <from>is_exist_getDateDim</from><to>create_func_getDateDim</to><enabled>Y</enabled> </hop>
  <hop> <from>is_exist_getDateDim</from><to>check_exist_getDateDim_olap</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exist_getDateDim_olap</from><to>Filter rows</to><enabled>Y</enabled> </hop>
  <hop> <from>Filter rows</from><to>create_func_getDateDim_olap</to><enabled>Y</enabled> </hop>
  <hop> <from>Filter rows</from><to>check_exist_generateSeriesBase</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exist_generateSeriesBase</from><to>Filter rows 2</to><enabled>Y</enabled> </hop>
  <hop> <from>Filter rows 2</from><to>create_proc_generateSeriesBase</to><enabled>Y</enabled> </hop>
  <hop> <from>Filter rows 2</from><to>check_exist_generateSeries</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exist_generateSeries</from><to>is_exist_generateSeries</to><enabled>Y</enabled> </hop>
  <hop> <from>is_exist_generateSeries</from><to>create_proc_generateSeries</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exist_trigger_acctg</from><to>if_not_exists_trigger_acctg</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_trigger_acctg</from><to>create_trigger</to><enabled>Y</enabled> </hop>
  <hop> <from>is_exist_generateSeries</from><to>check_exist_trigger_acctg</to><enabled>Y</enabled> </hop>
  <hop> <from>create_proc_generateSeries</from><to>check_exist_trigger_acctg</to><enabled>Y</enabled> </hop>
  <hop> <from>check_exists_func_get_parent</from><to>if_not_exists_func</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func</from><to>createFuncGetParent</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_trigger_acctg</from><to>check_exists_func_get_parent</to><enabled>Y</enabled> </hop>
  <hop> <from>create_trigger</from><to>check_exists_func_get_parent</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_exists_ICP</from><to>if_not_exists_ICP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ICP</from><to>createICP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func</from><to>check_Func_exists_ICP</to><enabled>Y</enabled> </hop>
  <hop> <from>createFuncGetParent</from><to>check_Func_exists_ICP</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_Total_Child</from><to>if_not_exists_TC</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_TC</from><to>createTC</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ICP</from><to>check_Pro_exists_Total_Child</to><enabled>Y</enabled> </hop>
  <hop> <from>createICP</from><to>check_Pro_exists_Total_Child</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_ACP</from><to>if_not_exists_ACP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ACP</from><to>createACP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_TC</from><to>check_Pro_exists_ACP</to><enabled>Y</enabled> </hop>
  <hop> <from>createTC</from><to>check_Pro_exists_ACP</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_COP</from><to>if_not_exists_COP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_COP</from><to>createOCP</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ACP</from><to>check_Func_COP</to><enabled>Y</enabled> </hop>
  <hop> <from>createACP</from><to>check_Func_COP</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_exists_ICGA</from><to>if_not_exists_ICGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ICGA</from><to>create_ICGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_COP</from><to>check_Func_exists_ICGA</to><enabled>Y</enabled> </hop>
  <hop> <from>createOCP</from><to>check_Func_exists_ICGA</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_TCGA</from><to>if_not_exists_TCGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_TCGA</from><to>createTCGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ICGA</from><to>check_Pro_exists_TCGA</to><enabled>Y</enabled> </hop>
  <hop> <from>create_ICGA</from><to>check_Pro_exists_TCGA</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_ACGA</from><to>if_not_exists_ACGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ACGA</from><to>createACGA</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_TCGA</from><to>check_Pro_exists_ACGA</to><enabled>Y</enabled> </hop>
  <hop> <from>createTCGA</from><to>check_Pro_exists_ACGA</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_exists_ICCT</from><to>if_not_exists_func_ICCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ICCT</from><to>create_func_ICCT</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_TCCT</from><to>if_not_exists_proc_TCCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_TCCT</from><to>create_proc_TCCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ICCT</from><to>check_Pro_exists_TCCT</to><enabled>Y</enabled> </hop>
  <hop> <from>create_func_ICCT</from><to>check_Pro_exists_TCCT</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_ACCT</from><to>if_not_exists_proc_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_ACCT</from><to>create_proc_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_TCCT</from><to>check_Pro_exists_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>create_proc_TCCT</from><to>check_Pro_exists_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_exists_ACCT</from><to>if_not_exists_func_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ACCT</from><to>create_func_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_ACCT</from><to>check_Func_exists_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>create_proc_ACCT</from><to>check_Func_exists_ACCT</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Func_exists_ICPI</from><to>if_not_exists_func_ICPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ICPI</from><to>create_func_ICPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ACCT</from><to>check_Func_exists_ICPI</to><enabled>Y</enabled> </hop>
  <hop> <from>create_func_ACCT</from><to>check_Func_exists_ICPI</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_TCPI</from><to>if_not_exists_proc_TCPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_TCPI</from><to>create_proc_TCPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_func_ICPI</from><to>check_Pro_exists_TCPI</to><enabled>Y</enabled> </hop>
  <hop> <from>create_func_ICPI</from><to>check_Pro_exists_TCPI</to><enabled>Y</enabled> </hop>
  <hop> <from>check_Pro_exists_ACPI</from><to>if_not_exists_proc_ACPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_ACPI</from><to>create_proc_ACPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_proc_TCPI</from><to>check_Pro_exists_ACPI</to><enabled>Y</enabled> </hop>
  <hop> <from>create_proc_TCPI</from><to>check_Pro_exists_ACPI</to><enabled>Y</enabled> </hop>
  <hop> <from>if_not_exists_ACGA</from><to>check_Func_exists_ICCT</to><enabled>Y</enabled> </hop>
  <hop> <from>createACGA</from><to>check_Func_exists_ICCT</to><enabled>Y</enabled> </hop>
  </order>
  <step>
    <name>Filter rows</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_exist_generateSeriesBase</send_true_to>
<send_false_to>create_func_getDateDim_olap</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_getDateDim_olap</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>338</xloc>
      <yloc>180</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>Filter rows 2</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_exist_generateSeries</send_true_to>
<send_false_to>create_proc_generateSeriesBase</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>proc_generateSeriesBase</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>483</xloc>
      <yloc>298</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_COP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_COP_TMP&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfParty&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1360</xloc>
      <yloc>1056</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_exists_ACCT</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_ACCT&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfCustomTime&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2512</xloc>
      <yloc>2016</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_exists_ICCT</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_ICCT&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getInnerChildCustomTime&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2080</xloc>
      <yloc>1680</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_exists_ICGA</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_ICGA&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getInnerChildGlAccount&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1504</xloc>
      <yloc>1168</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_exists_ICP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_ICP_TMP&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getInnerChildPartyRelation&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>928</xloc>
      <yloc>736</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Func_exists_ICPI</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_ICPI&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getInnerChildPartyInternal&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2656</xloc>
      <yloc>2144</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_ACCT</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_ACCT&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfCustomTime&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2368</xloc>
      <yloc>1904</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_ACGA</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_ACGA&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfGlAccount&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1792</xloc>
      <yloc>1408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_ACP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_ACP_temp&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfParty&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1216</xloc>
      <yloc>944</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_ACPI</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_ACPI&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getAllChildOfPartyInternal&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2944</xloc>
      <yloc>2400</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_TCCT</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_TCCT&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getTotalChildCustomTime&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2224</xloc>
      <yloc>1792</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_TCGA</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_TCGA&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getTotalChildGlAccount&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1648</xloc>
      <yloc>1280</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_TCPI</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_TCPI&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getTotalChildPartyInternal&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2800</xloc>
      <yloc>2272</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_Pro_exists_Total_Child</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as pro_get_total_child&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;getTotalChild&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1072</xloc>
      <yloc>848</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exist_generateSeries</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as proc_generateSeries &#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;generate_series_date_day&#x22; LIMIT 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>482</xloc>
      <yloc>408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exist_generateSeriesBase</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as proc_generateSeriesBase&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;PROCEDURE&#x27; AND ROUTINE_NAME &#x3d; &#x22;generate_series_date_day_base&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>339</xloc>
      <yloc>298</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exist_getDateDim</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_getDateDim&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x27;getDateDimensionId&#x27; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>80</xloc>
      <yloc>64</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exist_getDateDim_olap</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbiusolap</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_getDateDim_olap&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLAP&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;getDateDimensionId&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>204</xloc>
      <yloc>181</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exist_trigger_acctg</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbiusolap</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as trigger_acctg_tmp &#xa;FROM &#x28;SELECT TRIGGER_NAME FROM INFORMATION_SCHEMA.TRIGGERS&#xa;WHERE TRIGGER_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLAP&#x7d;&#x27; AND TRIGGER_NAME &#x3d; &#x27;trigger_acctg_document_fact&#x27; LIMIT 1&#x29; AS TMP</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>640</xloc>
      <yloc>512</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>check_exists_func_get_parent</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <sql>SELECT COUNT&#x28;&#x2a;&#x29; as func_getParent_tmp&#xa;FROM &#x28;SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES&#xa;WHERE ROUTINE_SCHEMA &#x3d; &#x27;&#x24;&#x7b;OLBIUS&#x7d;&#x27; AND ROUTINE_TYPE &#x3d; &#x27;FUNCTION&#x27; AND ROUTINE_NAME &#x3d; &#x22;funcGetParentRootCategoryOlbius&#x22; limit 1&#x29; AS TMP&#x3b;</sql>
    <limit>0</limit>
    <lookup/>
    <execute_each_row>N</execute_each_row>
    <variables_active>Y</variables_active>
    <lazy_conversion_active>N</lazy_conversion_active>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>784</xloc>
      <yloc>624</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createACGA</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create PROCEDURE getAllChildOfGlAccount&#x28;parentId varchar&#x28;60&#x29;&#x29;&#xa;begin&#xa;  declare childId varchar&#x28;60&#x29;&#x3b;&#xa;  declare listChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  call getTotalChildGlAccount&#x28;parentId, listChild&#x29;&#x3b;&#xa;  while &#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; DO&#xa;    set childId &#x3d; substring_index&#x28;listChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;    if &#x28;locate&#x28;&#x27;,&#x27;, listChild&#x29; &#x3c;&#x3d; 0&#x29; then &#xa;      set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;    if&#x28;char_length&#x28;childId&#x29; &#x3e; 0&#x29; then&#xa;      if &#x28;&#x28;select count&#x28;&#x2a;&#x29; from Temp_Olap_Gl_Account_Relation where parent_id &#x3d; parentId and child_id &#x3d; childId&#x29; &#x3c;&#x3d; 0&#x29; then&#xa;        insert into  Temp_Olap_Gl_Account_Relation &#x28;PARENT_ID, CHILD_ID, LAST_UPDATE&#x29; &#x28;select parentId as PARENT_ID, gl_account_id as childId, last_updated_stamp as last_update from gl_account&#xa;          where gl_account_id &#x3d; childId&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set listChild &#x3d; substring&#x28;listChild, char_length&#x28;childId&#x29; &#x2b; 2&#x29;&#x3b;&#xa;    else set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;  end while&#x3b;&#xa;end&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2080</xloc>
      <yloc>1408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createACP</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create PROCEDURE getAllChildOfParty&#x28;parentId varchar&#x28;60&#x29;&#x29;&#xa;begin&#xa;  declare childId varchar&#x28;60&#x29;&#x3b;&#xa;  declare listChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  call getTotalChild&#x28;parentId, listChild&#x29;&#x3b;&#xa;  while &#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; DO&#xa;    set childId &#x3d; substring_index&#x28;listChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;    if &#x28;locate&#x28;&#x27;,&#x27;, listChild&#x29; &#x3c;&#x3d; 0&#x29; then &#xa;      set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;    if&#x28;char_length&#x28;childId&#x29; &#x3e; 0&#x29; then&#xa;      if &#x28;&#x28;select count&#x28;&#x2a;&#x29; from temp_olap_party_group_relation where parent_id &#x3d; parentId and child_id &#x3d; childId&#x29; &#x3c;&#x3d; 0&#x29; then&#xa;        insert into Temp_Olap_Party_Group_Relation &#x28;PARENT_ID, CHILD_ID, FROM_DATE, THRU_DATE, last_update, TYPE&#x29; &#x28;SELECT parentId as PARENT_ID, r.party_id_to as CHILD_ID,&#xa;          CASE WHEN r.from_date &#x3c; p.created_date THEN p.created_date&#xa;          ELSE r.from_date END as FROM_DATE,&#xa;          r.thru_date as THRU_DATE,&#xa;          CASE WHEN r.last_updated_stamp &#x3c; p.created_date THEN p.created_date&#xa;            ELSE r.last_updated_stamp END as LAST_UPDATE,&#xa;          r.PARTY_RELATIONSHIP_TYPE_ID as TYPE&#xa;          FROM party_relationship AS r&#xa;          inner join party p on p.party_id &#x3d; r.party_id_from&#xa;          WHERE  r.party_id_to &#x3d; childId and r.party_relationship_type_id IN &#x28;&#x27;GROUP_ROLLUP&#x27;, &#x27;DISTRIBUTION&#x27;&#x29; &#xa;            AND r.role_type_id_from &#x21;&#x3d; &#x27;INTERNAL_ORGANIZATIO&#x27; limit 1&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set listChild &#x3d; substring&#x28;listChild, char_length&#x28;childId&#x29; &#x2b; 2&#x29;&#x3b;&#xa;    else set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;  end while&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1504</xloc>
      <yloc>944</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createFuncGetParent</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>CREATE FUNCTION funcGetParentRootCategoryOlbius &#x28;id VARCHAR&#x28;64&#x29;&#x29;&#xa;RETURNS VARCHAR&#x28;64&#x29;&#xa;BEGIN&#xa; DECLARE parent_id varchar&#x28;64&#x29;&#x3b;&#xa; DECLARE child_id varchar&#x28;64&#x29;&#x3b;&#xa; SET child_id &#x3d; id&#x3b;&#xa; SET parent_id &#x3d; null&#x3b;&#xa; SELECT primary_parent_category_id into parent_id &#xa; FROM product_category WHERE product_category_id &#x3d; id &#x3b;&#xa; &#xa; WHILE parent_id &#x3c;&#x3e; &#x27;DL_BROWSE_ROOT&#x27; DO&#xa;   SET child_id &#x3d; parent_id&#x3b;&#xa;   SET parent_id &#x3d; null&#x3b;&#xa;   SELECT primary_parent_category_id into parent_id&#xa;   FROM product_category WHERE product_category_id &#x3d; child_id&#x3b;&#xa; END WHILE&#x3b;&#xa; RETURN child_id&#x3b;&#xa;END&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1088</xloc>
      <yloc>624</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createICP</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getInnerChildPartyRelation&#x28;parentId varchar&#x28;60&#x29;&#x29; returns text&#xa;begin &#xa;  declare listChildId text&#x3b;&#xa;  select group_concat&#x28;party_id_to&#x29; into listChildId from party_relationship where party_id_from &#x3d; parentId and role_type_id_from &#x21;&#x3d; &#x27;INTERNAL_ORGAIZATIO&#x27;&#xa; AND party_relationship_type_id IN &#x28;&#x27;GROUP_ROLLUP&#x27;, &#x27;DISTRIBUTION&#x27;&#x29;&#x3b;&#xa;  return listChildId&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1216</xloc>
      <yloc>736</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createOCP</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getAllChildOfParty&#x28;parentId varchar&#x28;60&#x29;&#x29; returns varchar&#x28;60&#x29;&#xa;begin&#xa;  call getAllChildOfParty&#x28;parentId&#x29;&#x3b;&#xa;  return parentId&#x3b;&#xa;end&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1648</xloc>
      <yloc>1056</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createTC</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create procedure getTotalChild&#x28;party_id varchar&#x28;60&#x29;, out listChild text&#x29;&#xa;begin&#xa;  declare directChild text&#x3b;&#xa;  declare loopChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  declare childOfChild char&#x28;60&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  set directChild &#x3d; getInnerChildPartyRelation&#x28;party_id&#x29;&#x3b;&#xa;  set listChild &#x3d; directChild&#x3b;&#xa;  if &#x28;char_length&#x28;directChild&#x29; &#x3e; 0&#x29; then&#xa;    set listChild &#x3d;  directChild&#x3b;&#xa;    while&#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; do&#xa;      set childOfChild &#x3d; substring_index&#x28;directChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;      set loopChild &#x3d; getInnerChildPartyRelation&#x28;childOfChild&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;loopChild&#x29; &#x3e; 0&#x29; then&#xa;        set directChild &#x3d; concat&#x28;directChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set directChild &#x3d; substring&#x28;directChild, char_length&#x28;childOfChild&#x29; &#x2b; 2&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;directChild&#x29; &#x3c;&#x3d; 0&#x29; then set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;      end if&#x3b;&#xa;  end while&#x3b;&#xa;  end if&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1360</xloc>
      <yloc>848</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>createTCGA</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create procedure getTotalChildGlAccount&#x28;glAccountId varchar&#x28;60&#x29;, out listChild text&#x29;&#xa;begin&#xa;  declare directChild text&#x3b;&#xa;  declare loopChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  declare childOfChild char&#x28;60&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  set directChild &#x3d; getInnerChildGlAccount&#x28;glAccountId&#x29;&#x3b;&#xa;  set listChild &#x3d; directChild&#x3b;&#xa;  if &#x28;char_length&#x28;directChild&#x29; &#x3e; 0&#x29; then&#xa;    set listChild &#x3d; directChild&#x3b;&#xa;    while&#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; do&#xa;      set childOfChild &#x3d; substring_index&#x28;directChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;      set loopChild &#x3d; getInnerChildGlAccount&#x28;childOfChild&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;loopChild&#x29; &#x3e; 0&#x29; then&#xa;        set directChild &#x3d; concat&#x28;directChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;        set listChild &#x3d; concat&#x28;listChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set directChild &#x3d; substring&#x28;directChild, char_length&#x28;childOfChild&#x29; &#x2b; 2&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;directChild&#x29; &#x3c;&#x3d; 0&#x29; then set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;      end if&#x3b;&#xa;  end while&#x3b;&#xa;  end if&#x3b;&#xa;end&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1936</xloc>
      <yloc>1280</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_ICGA</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getInnerChildGlAccount&#x28;glAccountId varchar&#x28;60&#x29;&#x29; returns text&#xa;begin &#xa;  declare listChildId text&#x3b;&#xa;  select group_concat&#x28;gl_account_id&#x29; into listChildId from gl_account where PARENT_GL_ACCOUNT_ID &#x3d; glAccountId&#x3b;&#xa;  return listChildId&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1792</xloc>
      <yloc>1168</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_func_ACCT</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getAllChildOfCustomTime&#x28;parentId varchar&#x28;60&#x29;&#x29; returns varchar&#x28;60&#x29;&#xa;begin&#xa;  call getAllChildOfCustomTime&#x28;parentId&#x29;&#x3b;&#xa;  return parentId&#x3b;&#xa;end&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2800</xloc>
      <yloc>2016</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_func_ICCT</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getInnerChildCustomTime&#x28;customTimePeriodId varchar&#x28;60&#x29;&#x29; returns text&#xa;begin &#xa;  declare listChildId text&#x3b;&#xa;  select group_concat&#x28;CUSTOM_TIME_PERIOD_ID&#x29; into listChildId from custom_time_period where PARENT_PERIOD_ID &#x3d; customTimePeriodId&#x3b;&#xa;  return listChildId&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2368</xloc>
      <yloc>1680</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_func_ICPI</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create function getInnerChildPartyInternal&#x28;parentId varchar&#x28;60&#x29;&#x29; returns text&#xa;begin &#xa;  declare listChildId text&#x3b;&#xa;  select group_concat&#x28;party_id_to&#x29; into listChildId from party_relationship where party_id_from &#x3d; parentId and role_type_id_from &#x21;&#x3d; &#x27;PARENT_MEMBER&#x27;&#xa; AND party_relationship_type_id &#x3d; &#x27;GROUP_ROLLUP&#x27;&#x3b;&#xa;  return listChildId&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2944</xloc>
      <yloc>2144</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_func_getDateDim</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>CREATE FUNCTION &#x60;getDateDimensionId&#x60;&#x28;valueParam datetime&#x29; RETURNS decimal&#x28;10,0&#x29;&#xa;BEGIN&#xa;	DECLARE select_var numeric&#x3b;&#xa;	SET select_var &#x3d; &#x28;select case when valueParam is not null then ceil&#x28;UNIX_TIMESTAMP&#x28;CONVERT_TZ&#x28;valueParam, &#x27;&#x2b;00&#x3a;00&#x27;, &#x40;&#x40;global.time_zone&#x29;&#x29;&#x29; else -1 end&#x29;&#x3b;&#xa;	RETURN select_var&#x3b;&#xa;END</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>349</xloc>
      <yloc>64</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_func_getDateDim_olap</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbiusolap</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>CREATE FUNCTION &#x60;getDateDimensionId&#x60;&#x28;valueParam datetime&#x29; RETURNS decimal&#x28;10,0&#x29;&#xa;BEGIN&#xa;	DECLARE select_var numeric&#x3b;&#xa;	SET select_var &#x3d; &#x28;select case when valueParam is not null then ceil&#x28;UNIX_TIMESTAMP&#x28;CONVERT_TZ&#x28;valueParam, &#x27;&#x2b;00&#x3a;00&#x27;, &#x40;&#x40;global.time_zone&#x29;&#x29;&#x29; else -1 end&#x29;&#x3b;&#xa;	RETURN select_var&#x3b;&#xa;END</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>481</xloc>
      <yloc>181</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_ACCT</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create PROCEDURE getAllChildOfCustomTime&#x28;parentId varchar&#x28;60&#x29;&#x29;&#xa;begin&#xa;  declare childId varchar&#x28;60&#x29;&#x3b;&#xa;  declare listChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  call getTotalChildCustomTime&#x28;parentId, listChild&#x29;&#x3b;&#xa;  while &#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; DO&#xa;    if &#x28;locate&#x28;&#x27;,&#x27;, listChild&#x29; &#x3c;&#x3d; 0&#x29; then &#xa;      set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;    set childId &#x3d; substring_index&#x28;listChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;    if&#x28;char_length&#x28;childId&#x29; &#x3e; 0&#x29; then&#xa;      if &#x28;&#x28;select count&#x28;&#x2a;&#x29; from temp_olap_custom_time_relation where parent_id &#x3d; parentId and child_id &#x3d; childId&#x29; &#x3c;&#x3d; 0&#x29; then&#xa;        insert into  temp_olap_custom_time_relation &#x28;parent_id, child_id, last_update&#x29; &#x28;select parentId as parent_id, custom_time_period_id as childId, last_updated_stamp as last_update from custom_time_period&#xa;          where custom_time_period_id &#x3d; childId&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set listChild &#x3d; substring&#x28;listChild, char_length&#x28;childId&#x29; &#x2b; 2&#x29;&#x3b;&#xa;    else set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;  end while&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2656</xloc>
      <yloc>1904</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_ACPI</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create PROCEDURE getAllChildOfPartyInternal&#x28;parentId varchar&#x28;60&#x29;&#x29;&#xa;begin&#xa;  declare childId varchar&#x28;60&#x29;&#x3b;&#xa;  declare listChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  call getTotalChildPartyInternal&#x28;parentId, listChild&#x29;&#x3b;&#xa;  while &#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; DO&#xa;    set childId &#x3d; substring_index&#x28;listChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;    if &#x28;locate&#x28;&#x27;,&#x27;, listChild&#x29; &#x3c;&#x3d; 0&#x29; then &#xa;      set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;    if&#x28;char_length&#x28;childId&#x29; &#x3e; 0&#x29; then&#xa;      if &#x28;&#x28;select count&#x28;&#x2a;&#x29; from temp_olap_party_group_relation where parent_id &#x3d; parentId and child_id &#x3d; childId&#x29; &#x3c;&#x3d; 0&#x29; then&#xa;        insert into Temp_Olap_Party_Group_Relation &#x28;PARENT_ID, CHILD_ID, FROM_DATE, THRU_DATE, last_update, TYPE&#x29; &#x28;SELECT parentId as PARENT_ID, r.party_id_to as CHILD_ID,&#xa;          r.from_date as FROM_DATE,&#xa;          r.thru_date as THRU_DATE, &#xa;          r.last_updated_stamp as LAST_UPDATE,&#xa;          r.PARTY_RELATIONSHIP_TYPE_ID as TYPE&#xa;          FROM party_relationship AS r&#xa;          WHERE r.party_id_to &#x3d; childId&#xa;            and r.party_relationship_type_id &#x3d; &#x27;GROUP_ROLLUP&#x27; limit 1&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set listChild &#x3d; substring&#x28;listChild, char_length&#x28;childId&#x29; &#x2b; 2&#x29;&#x3b;&#xa;    else set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;    end if&#x3b;&#xa;  end while&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>3232</xloc>
      <yloc>2400</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_TCCT</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create procedure getTotalChildCustomTime&#x28;customTimeId varchar&#x28;60&#x29;, out listChild text&#x29;&#xa;begin&#xa;  declare directChild text&#x3b;&#xa;  declare loopChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  declare childOfChild char&#x28;60&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  set directChild &#x3d; getInnerChildCustomTime&#x28;customTimeId&#x29;&#x3b;&#xa;  set listChild &#x3d; directChild&#x3b;&#xa;  if &#x28;char_length&#x28;directChild&#x29; &#x3e; 0&#x29; then&#xa;    set listChild &#x3d; directChild&#x3b;&#xa;    while&#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; do&#xa;      set childOfChild &#x3d; substring_index&#x28;directChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;      set loopChild &#x3d; getInnerChildCustomTime&#x28;childOfChild&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;loopChild&#x29; &#x3e; 0&#x29; then&#xa;        set directChild &#x3d; concat&#x28;directChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;        set listChild &#x3d; concat&#x28;listChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set directChild &#x3d; substring&#x28;directChild, char_length&#x28;childOfChild&#x29; &#x2b; 2&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;directChild&#x29; &#x3c;&#x3d; 0&#x29; then set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;      end if&#x3b;&#xa;  end while&#x3b;&#xa;  end if&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2512</xloc>
      <yloc>1792</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_TCPI</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create procedure getTotalChildPartyInternal&#x28;party_id varchar&#x28;60&#x29;, out listChild text&#x29;&#xa;begin&#xa;  declare directChild text&#x3b;&#xa;  declare loopChild text&#x3b;&#xa;  declare flag char&#x28;1&#x29;&#x3b;&#xa;  declare childOfChild char&#x28;60&#x29;&#x3b;&#xa;  set flag &#x3d; &#x27;Y&#x27;&#x3b;&#xa;  set directChild &#x3d; getInnerChildPartyInternal&#x28;party_id&#x29;&#x3b;&#xa;  set listChild &#x3d; directChild&#x3b;&#xa;  if &#x28;char_length&#x28;directChild&#x29; &#x3e; 0&#x29; then&#xa;    set listChild &#x3d;  directChild&#x3b;&#xa;    while&#x28;flag &#x21;&#x3d; &#x27;N&#x27;&#x29; do&#xa;      set childOfChild &#x3d; substring_index&#x28;directChild, &#x27;,&#x27;, 1&#x29;&#x3b;&#xa;      set loopChild &#x3d; getInnerChildPartyInternal&#x28;childOfChild&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;loopChild&#x29; &#x3e; 0&#x29; then&#xa;        set directChild &#x3d; concat&#x28;directChild, &#x27;,&#x27;, loopChild&#x29;&#x3b;&#xa;      end if&#x3b;&#xa;      set directChild &#x3d; substring&#x28;directChild, char_length&#x28;childOfChild&#x29; &#x2b; 2&#x29;&#x3b;&#xa;      if&#x28;char_length&#x28;directChild&#x29; &#x3c;&#x3d; 0&#x29; then set flag &#x3d; &#x27;N&#x27;&#x3b;&#xa;      end if&#x3b;&#xa;  end while&#x3b;&#xa;  end if&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>3088</xloc>
      <yloc>2272</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_generateSeries</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>CREATE PROCEDURE generate_series_date_day &#x28;IN n_first DATE, IN n_last DATE, IN n_increment CHAR&#x28;40&#x29;&#x29;&#xa;BEGIN&#xa;    -- Call base stored procedure&#xa;    CALL generate_series_date_day_base&#x28;n_first, n_last, n_increment&#x29;&#x3b;&#xa;    &#xa;    -- Output&#xa;    SELECT &#x2a; FROM series_tmp&#x3b;&#xa;END&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>793</xloc>
      <yloc>408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_proc_generateSeriesBase</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbius</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>CREATE PROCEDURE &#x60;generate_series_date_day_base&#x60;&#x28;IN n_first DATETIME, IN n_last DATETIME, IN n_increment CHAR&#x28;40&#x29;&#x29;&#xa;BEGIN&#xa;    -- Create tmp table&#xa;    DROP TEMPORARY TABLE IF EXISTS series_tmp&#x3b;&#xa;    CREATE TEMPORARY TABLE series_tmp &#x28;&#xa;		dim_id numeric,&#xa;        date_value DATE&#xa;    &#x29; engine &#x3d; memory&#x3b;&#xa;    &#xa;    WHILE n_first  &#x3c;&#x3d; n_last DO&#xa;        -- Insert in tmp table&#xa;        INSERT INTO series_tmp &#x28;dim_id, date_value&#x29; VALUES &#x28;getDateDimensionId&#x28;n_first&#x29;, CAST&#x28;n_first AS DATE&#x29;&#x29;&#x3b;&#xa;&#xa;        -- Increment value by one&#xa;        SELECT DATE_ADD&#x28;n_first, INTERVAL &#x2b;n_increment day&#x29; INTO n_first&#x3b;&#xa;    END WHILE&#x3b;&#xa;END&#x3b;&#xa;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>636</xloc>
      <yloc>298</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>create_trigger</name>
    <type>ExecSQL</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
    <connection>olbiusolap</connection>
    <execute_each_row>Y</execute_each_row>
    <single_statement>Y</single_statement>
    <replace_variables>N</replace_variables>
    <quoteString>N</quoteString>
    <sql>create trigger trigger_acctg_document_fact&#xa;after update on acctg_document_list_fact&#xa;for each row&#xa;begin&#xa;    UPDATE acctg_custom_time_period_sum_fact SET last_processed_stamp &#x3d; NEW.last_updated_stamp&#xa;    WHERE gl_account_id &#x3d; NEW.gl_account_id&#xa;    AND custom_time_period_id IN &#x28;SELECT custom_time_period_id FROM custom_time_period_dimension ctpd &#xa;    WHERE ctpd.period_type_id like &#x27;FISCAL_&#x25;&#x27; AND &#x28;NEW.transaction_date &#x3e;&#x3d; ctpd.from_date AND NEW.transaction_date&#x3c;&#x3d; ctpd.thru_date&#x29;&#x29;&#x3b;&#xa;    UPDATE acctg_custom_time_party_sum_fact SET last_processed_stamp &#x3d; NEW.last_updated_stamp&#xa;    WHERE gl_account_id &#x3d; NEW.gl_account_id&#xa;    AND custom_time_period_id IN &#x28;SELECT custom_time_period_id FROM custom_time_period_dimension ctpd &#xa;    WHERE ctpd.period_type_id like &#x27;FISCAL_&#x25;&#x27; AND &#x28;NEW.transaction_date &#x3e;&#x3d; ctpd.from_date AND NEW.transaction_date&#x3c;&#x3d; ctpd.thru_date&#x29;&#xa;    AND party_id &#x3d; NEW.party_id&#x29;&#x3b;&#xa;end&#x3b;</sql>
    <set_params>Y</set_params>
    <insert_field/>
    <update_field/>
    <delete_field/>
    <read_field/>
    <arguments>
    </arguments>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>944</xloc>
      <yloc>512</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_ACGA</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ICCT</send_true_to>
<send_false_to>createACGA</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_ACGA</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1936</xloc>
      <yloc>1408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_ACP</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_COP</send_true_to>
<send_false_to>createACP</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_ACP_temp</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1360</xloc>
      <yloc>944</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_COP</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ICGA</send_true_to>
<send_false_to>createOCP</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_COP_TMP</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1504</xloc>
      <yloc>1056</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_ICGA</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_TCGA</send_true_to>
<send_false_to>create_ICGA</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_ICGA</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1648</xloc>
      <yloc>1168</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_ICP</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_Total_Child</send_true_to>
<send_false_to>createICP</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_ICP_TMP</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1072</xloc>
      <yloc>736</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_TC</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_ACP</send_true_to>
<send_false_to>createTC</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_get_total_child</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1216</xloc>
      <yloc>848</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_TCGA</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_ACGA</send_true_to>
<send_false_to>createTCGA</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_TCGA</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>1792</xloc>
      <yloc>1280</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_func</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ICP</send_true_to>
<send_false_to>createFuncGetParent</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_getParent_tmp</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>928</xloc>
      <yloc>624</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_func_ACCT</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ICPI</send_true_to>
<send_false_to>create_func_ACCT</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_ACCT</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2656</xloc>
      <yloc>2016</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_func_ICCT</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_TCCT</send_true_to>
<send_false_to>create_func_ICCT</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_ICCT</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2224</xloc>
      <yloc>1680</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_func_ICPI</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_TCPI</send_true_to>
<send_false_to>create_func_ICPI</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_ICPI</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2800</xloc>
      <yloc>2144</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_proc_ACCT</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ACCT</send_true_to>
<send_false_to>create_proc_ACCT</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_ACCT</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2512</xloc>
      <yloc>1904</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_proc_ACPI</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Func_exists_ACPI</send_true_to>
<send_false_to>create_proc_ACPI</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_ACPI</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>3088</xloc>
      <yloc>2400</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_proc_TCCT</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_ACCT</send_true_to>
<send_false_to>create_proc_TCCT</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_TCCT</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2368</xloc>
      <yloc>1792</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_proc_TCPI</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_Pro_exists_ACPI</send_true_to>
<send_false_to>create_proc_TCPI</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>pro_TCPI</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>2944</xloc>
      <yloc>2272</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>if_not_exists_trigger_acctg</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_exists_func_get_parent</send_true_to>
<send_false_to>create_trigger</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>trigger_acctg_tmp</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>784</xloc>
      <yloc>512</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>is_exist_generateSeries</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_exist_trigger_acctg</send_true_to>
<send_false_to>create_proc_generateSeries</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>proc_generateSeries</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>638</xloc>
      <yloc>408</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step>
    <name>is_exist_getDateDim</name>
    <type>FilterRows</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
         <partitioning>
           <method>none</method>
           <schema_name/>
           </partitioning>
<send_true_to>check_exist_getDateDim_olap</send_true_to>
<send_false_to>create_func_getDateDim</send_false_to>
    <compare>
<condition>
 <negated>N</negated>
 <leftvalue>func_getDateDim</leftvalue>
 <function>&#x3e;&#x3d;</function>
 <rightvalue/>
 <value><name>constant</name><type>Integer</type><text>1</text><length>-1</length><precision>0</precision><isnull>N</isnull><mask>&#x23;&#x3b;-&#x23;</mask></value> </condition>
    </compare>
     <cluster_schema/>
 <remotesteps>   <input>   </input>   <output>   </output> </remotesteps>    <GUI>
      <xloc>204</xloc>
      <yloc>64</yloc>
      <draw>Y</draw>
      </GUI>
    </step>

  <step_error_handling>
  </step_error_handling>
   <slave-step-copy-partition-distribution>
</slave-step-copy-partition-distribution>
   <slave_transformation>N</slave_transformation>

</transformation>
